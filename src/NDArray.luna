import Std.Foreign.C.Value
import Std.Foreign

import Dataframes.Scanf
import Dataframes.Types


class NDArray a:
    NDArray a
    NDArrayVal (List Int) (List Int) Int (ManagedPointer a)

    def _cSym name:
        lookupSymbol "2d_array" name

    def _cCall name ret args:
        self . _cSym name . call ret args

    def ptr: case self of
        NDArray a: ManagedPointer a
        NDArrayVal _ _ _ p: p

    def size: case self of
        NDArrayVal s _ _ _:s

    def stride: case self of
        NDArrayVal _ stride _ _: stride

    def offset: case self of
        NDArrayVal _ _ offset _: offset

    def elems: self.size.fold 1 (*)

    def forEach f: 0 . upto self.elems-1 . each k:
        indexN = self.tmp k
        f indexN

    def forEachLinear f: 0 . upto self.elems-1 . each k: f k

    def make: NDArrayVal

    def alloc size :
        elems = size.fold 1 (*)
        stride = case size.length of
            0: throw "Empty size list"
            1: [1]
            _: size.tail.get + [1]
        offset = 0
        ptr = self.ptr.mallocElems elems
        NDArrayVal size stride offset ptr

    def free:
        self.ptr.free

    def unsafeElemPointer index:
        lsMatch = index.length == self.size.length
        elemSize = index.zipWith (*) self.stride
        elems = elemSize.fold self.offset (+)
        self . ptr . moveElems elems


    def assertInBounds index:
        lsMatch = index.length == self.size.length
        allLess = index.zipWith (<) self.size . _all (== True)
        allNonZero = index._all (>= 0)
        inBounds = lsMatch . and allLess . and allNonZero
        when (inBounds.not) (throw "Array index out of bounds.")

    def uncheckedReadAt index:
        pointer = self . unsafeElemPointer index
        pointer.read

    def readAt index:
        self.assertInBounds index
        self.uncheckedReadAt index

    def uncheckedWriteAt index val:
        self . unsafeElemPointer index . write val

    def writeAt index val:
        self.assertInBounds index
        self.uncheckedWriteAt index val

    def elemPointer index:
        self.assertInBounds index
        self.unsafeElemPointer index

    def tmp flatIndex: self.tmp2 flatIndex self.size []

    def tmp2 flatIndex size acc:
        case size of
            Prepend x xs :
                n = xs.fold 1 (*)
                accNew =  acc.prepend (flatIndex/n)
                self.tmp2 (flatIndex % n) xs accNew
            Empty:
                index = acc.reverse
                index

    def toList:
        self.forEach (indexN:
            pointer = self.elemPointer indexN
            case pointer.read.isNull of
                False:
                    pointer . read . toText
                True: "")


    def cDropRow n:
        rows = self.size.head.get
        cols = self.size.getAt 1
        stride_r = self.stride.head.get
        stride_c = self.stride.getAt 1

        new_mat = self._cCall "drop_row" (Pointer CString) [self.ptr . toCArg, CSize.fromInt rows . toCArg, CSize.fromInt cols . toCArg, CSize.fromInt stride_r . toCArg, CSize.fromInt stride_c . toCArg, CInt.fromInt n . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self._cSym "mat_delete") new_mat
        NDArrayVal [rows-1, cols] self.stride 0 matManaged

    def mapRow n ft f:
        x = NDArrayVal (self.size.tail.get) (self.stride.tail.get) n*(self.stride.getAt 0) self.ptr
        x.forEach indexN:
            record = x.elemPointer indexN
            cstringPointer = record.read
            string = cstringPointer.toText
            cstringPointer.free
            modifiedRecord = case ft of
                FieldReal:
                    real = scanf string
                    value = ValueReal real
                    f value
                _:
                    value = ValueText string
                    f value
            record.write (CString.fromText modifiedRecord.toText)
        self

    def mapColumn n f:
        x = NDArrayVal (self.size.take 1) (self.stride.take 1) n self.ptr
        x.forEach indexN:
            record = x.elemPointer indexN
            cdoublePointer = record.read
            modifiedRecord = f cdoublePointer
            record.write  modifiedRecord
        self

    def findNA:
        self.forEach indexN:
            pointer = self.elemPointer indexN
            if pointer.read.isNull then (Just indexN) else Nothing

    def map f:
        self.forEach indexN:
            pointer = self.elemPointer indexN
            elem = pointer.read
            case elem.isNull of
                True: Pointer None . null
                False:
                    value = f elem
                    elem.free
                    elem.write value

    def copyColumns listOfColumns:
        l = listOfColumns.length
        rows = self.size.head.get
        cols = self.size.getAt 1
        stride_r = self.stride.head.get
        stride_c = self.stride.getAt 1
        columnsArray = Array CInt . fromList (listOfColumns . map CInt.fromInt)
        new_mat = self._cCall "copy_columns" (Pointer CString) [self.ptr . toCArg, CSize.fromInt rows . toCArg, CSize.fromInt cols . toCArg, CSize.fromInt stride_r . toCArg, CSize.fromInt stride_c . toCArg, CInt.fromInt l . toCArg, columnsArray.ptr . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self._cSym "mat_delete") new_mat
        NDArrayVal [rows, l] [l, stride_c] 0 matManaged

    def copyRows listOfRows:
        l = listOfRows.length
        rows = self.size.head.get
        cols = self.size.getAt 1
        stride_r = self.stride.head.get
        stride_c = self.stride.getAt 1
        rowsArray = Array CInt . fromList (listOfRows . map CInt.fromInt)
        new_mat = self._cCall "copy_rows" (Pointer CString) [self.ptr . toCArg, CSize.fromInt rows . toCArg, CSize.fromInt cols . toCArg, CSize.fromInt stride_r . toCArg, CSize.fromInt stride_c . toCArg, CInt.fromInt l . toCArg, rowsArray.ptr . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self._cSym "mat_delete") new_mat
        NDArrayVal [l, cols] self.stride 0 matManaged

    def cTranspose:
        rows = self.size.head.get
        cols = self.size.getAt 1
        stride_r = self.stride.head.get
        stride_c = self.stride.getAt 1
        new_mat = self._cCall "transpose" (Pointer CString) [self.ptr . toCArg, CSize.fromInt rows . toCArg, CSize.fromInt cols . toCArg, CSize.fromInt stride_r . toCArg, CSize.fromInt stride_c . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self._cSym "mat_delete") new_mat
        NDArrayVal [cols,rows] [rows,1] 0 matManaged

    def join arrayToJoin:
        fstRows = self.size.head.get
        fstCols = self.size.getAt 1
        sndRows = arrayToJoin.size.head.get
        sndCols = arrayToJoin.size.getAt 1
        new_mat = self._cCall "join" (Pointer CString) [self.ptr . toCArg, arrayToJoin.ptr . toCArg, CSize.fromInt fstRows . toCArg, CSize.fromInt fstCols . toCArg, CSize.fromInt sndRows . toCArg, CSize.fromInt sndCols . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self._cSym "mat_delete") new_mat
        NDArrayVal [fstRows+sndRows,cols] [fstCols,1] 0 matManaged
