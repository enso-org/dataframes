import Std.Foreign.C.Value
import Std.Foreign
import Dataframes.Array2D
import Dataframes.Utils 
import Dataframes.Types

class Dataframe:
    Dataframe
    DataframeVal:
        header:: Maybe (Array2D CString)
        type  :: List FieldType
        data  :: Array2D CString

    def cSym name:
        lookupSymbol "DataframeHelper" name

    def header: case self of
        DataframeVal h _ _: h
    
    def headerList:
        self.header . map (x: x.toFlatList)

    def type: case self of
        DataframeVal _ t _: t

    def data: case self of
        DataframeVal _ _ d: d

    def readFromCSV file readHeader:
        commaSeparator = CChar.fromInt 44
        mat = cCallHandlingError "read_csv" (Pointer CString) [CString.fromText file . toCArg, commaSeparator.toCArg]
        matManaged = ManagedPointer CString . fromPointer (self.cSym "mat_delete") mat
        r = rowCount matManaged
        c = columnCount matManaged
        type = 0 . upto c . each (k: FieldReal)
        case readHeader of
            True:
                headerArray = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . copyRows [0]
                data   = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . cDropRow 0 
                transposed = data.cTranspose
                DataframeVal (Just headerArray) type transposed
            False:
                DataframeVal Nothing type ((Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged) . cTranspose)

    def writeToCSV filename:
        commaSeparator = CChar.fromInt 44
        withHeader = case self.header of
            Nothing: self.data.cTranspose
            Just h :
                dataT = self.data.cTranspose
                h.join dataT
        cCallHandlingError "write_csv" None [CString.fromText filename . toCArg, withHeader.getPtr . toCArg, commaSeparator.toCArg]

    def readFromXlsx file readHeader:
        mat = cCallHandlingError "read_xlsx" (Pointer CString) [CString.fromText file . toCArg]
        matManaged = ManagedPointer CString . fromPointer (self.cSym "mat_delete") mat
        r = rowCount matManaged
        c = columnCount matManaged
        type = 0 . upto c . each (k: FieldReal)
        case readHeader of
            True:
                headerArray = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . copyRows [0]
                data   = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . cDropRow 0 
                transposed = data.cTranspose
                DataframeVal (Just headerArray) type transposed
            False:
                DataframeVal Nothing type ((Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged) . cTranspose)

    def at x y:
        record = self.data.readAt [y,x]
        record

    def selectColumns x:
        newHeader = self.header . map (k: k.copyColumns x)

        newType = x.foldLeft [] (self.selectItems self.type)
        newData = self.data.copyRows x
        DataframeVal newHeader newType newData

    def dropRows list:
        rows = 0 . upto (self.data.getSize.columns-1)
        x = rows.filter (k: list . contains k . not)
        newFrame = self.selectRows x
        newFrame

    def selectRows x:
        newData = self.data.copyColumns x
        DataframeVal self.header self.type newData

    def selectItems l1 x l2:
        n = l1.getAt x
        l22 = l2 + [n]
        l22

    def selectColumnRange a b:
        range = a . upto b
        self.selectColumns range

    def selectRowRange a b:
        range = a . upto b
        self.selectRows range

    def mapColumn n f:
        newData = self.data.mapRow n (self.type.getAt n) f
        DataframeVal self.header self.type newData

    def nubOrd l: self.nubOrd2 [] l 

    def nubOrd2 s l:
        case l of
            Prepend x xs: if (s.contains x) then (self.nubOrd2 s xs) else Prepend x (self.nubOrd2 (s.prepend x) xs)
            Empty: []
                    

    def dropNA:
        naList = self.data.findNA . filter (k: k.isJust)
        rows = naList.each (k: k.get . getAt 1) . sort . reverse
        s = self.nubOrd rows 
        dropped = self.dropRows s
        dropped

    def fillNAColumn n x:
        clonedData = self.data.clone
        newArray = Array2DVal self.data.getSize self.data.getStride 0 clonedData
        naList = self.data.findNA . filter (k: k.isJust)
        naInColumn = naList.filter (k: k.get . getAt 0 == n)
        naInColumn.each (k: newArray.store k.get.reverse x.toText)
        DataframeVal self.header self.type newArray

    def toJSON:
        transposedData = self.data.cTranspose
        JSON.empty . insert "header" self.headerList . insert "data" transposedData.toList
