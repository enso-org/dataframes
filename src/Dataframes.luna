import Std.Foreign.C.Value
import Std.Foreign
import Dataframes.NDArray
import Dataframes.Types

class Dataframe:
    Dataframe
    DataframeVal:
        header:: Maybe (List Text)
        type  :: List FieldType
        data  :: NDArray CString

    def _cSym name:
        lookupSymbol "csv" name

    def _cStdSym name:
        lookupSymbol cStdLib name

    def _cCall name ret args:
        self . _cSym name . call ret args

    def header: case self of
        DataframeVal h _ _: h

    def type: case self of
        DataframeVal _ t _: t

    def data: case self of
        DataframeVal _ _ d: d

    def readFromCSV file readHeader:
        rows = ManagedPointer CInt . malloc
        cols = ManagedPointer CInt . malloc
        err = ManagedPointer CInt . malloc
        mat = self._cCall "read_csv" (Pointer CString) [CString.fromText file . toCArg, rows.toCArg, cols.toCArg, err.toCArg]
        matManaged = case err.read.toInt of
            0: ManagedPointer CString . fromPointer (self._cSym "mat_delete") mat
            _: throw err.read.toText
        r = rows.read.toInt
        c = cols.read.toInt
        type = 0 . upto c . each (k: FieldReal)
        case readHeader of
            True:
                headerArray = NDArrayVal (SizeVal r c) [c,1] 0 matManaged . copyRows [0]
                header = headerArray . toFlatList
                data   = NDArrayVal (SizeVal r c) [c,1] 0 matManaged . cDropRow 0 . cTranspose
                DataframeVal (Just header) type data
            False:
                DataframeVal Nothing type ((NDArrayVal (SizeVal r c) [c,1] 0 matManaged) . cTranspose)

    def writeToCSV filename:
        withHeader = case self.header of
            Nothing: self.data.cTranspose
            Just h :
                    headerArray = Array CString . fromList (h . map CString.fromText)
                    managed = ManagedPointer CString . fromPointer (self._cStdSym "free") headerArray.ptr
                    headerNDArray = NDArrayVal (SizeVal 1 h.length) [1,1] 0 managed
                    dataT = self.data.cTranspose
                    headerNDArray.join dataT
        rows = withHeader.getSize.getRows
        cols = withHeader.getSize.getColumns
        err = ManagedPointer CInt . malloc
        self._cCall "write_csv" None [CString.fromText filename . toCArg, withHeader.getPtr . toCArg, CInt.fromInt rows . toCArg, CInt.fromInt cols . toCArg, err.toCArg]
        case err.read.toInt of
            0: None
            _: throw err.read.toText

    def at x y:
        record = self.data.readAt [y,x]
        record

    def selectColumns x:
        newHeader = self.header.map (h: x.foldLeft [] (self.selectItems h))

        newType = x.foldLeft [] (self.selectItems self.type)
        newData = self.data.copyRows x
        DataframeVal newHeader newType newData

    def selectColumnsByNames listOfNames:
        None

    def dif a b:
        (a == b).not

    def dropRows list:
        rows = 0 . upto (self.data.getSize.getRows)
        x = rows.filter (k: list._any (Dataframe.dif k))
        newFrame = self.selectRows x
        newFrame

    def selectRows x:
        newData = self.data.copyColumns x
        DataframeVal self.header self.type newData

    def selectItems l1 x l2:
        n = l1.getAt x
        l22 = l2 + [n]
        l22

    def selectColumnRange a b:
        range = a . upto b
        self.selectColumns range

    def selectRowRange a b:
        range = a . upto b
        self.selectRows range

    def mapColumn n f:
        newData = self.data.mapRow n (self.type.getAt n) f
        DataframeVal self.header self.type newData

    def dropNA:
        naList = self.data.findNA . filter (k: k.isJust)
        rows = naList.each (k: k.get . head . get)
        self.dropRows rows

    def toJSON:
        transposedData = self.data.cTranspose
        JSON.empty . insert "header" self.header . insert "data" transposedData.toList
