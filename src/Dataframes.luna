import Std.Foreign.C.Value
import Std.Foreign
import Dataframes.Array2D
import Dataframes.Utils 
import Dataframes.Types

class Dataframe:
    Dataframe
    DataframeVal:
        header:: Maybe (Array2D CString)
        type  :: List FieldType
        data  :: Array2D CString

    def cSym name:
        lookupSymbol "DataframeHelper" name

    def cStdSym name:
        lookupSymbol cStdLib name

    def cCall name ret args:
        self . cSym name . call ret args

    def header: case self of
        DataframeVal h _ _: h
    
    def headerList:
        self.header . map (x: x.toFlatList)

    def type: case self of
        DataframeVal _ t _: t

    def data: case self of
        DataframeVal _ _ d: d

    def readFromCSV file readHeader:
        rows = ManagedPointer CInt . malloc
        cols = ManagedPointer CInt . malloc
        err  = ManagedPointer CInt . malloc
        mat  = self.cCall "read_csv" (Pointer CString) [CString.fromText file . toCArg, rows.toCArg, cols.toCArg, err.toCArg]
        matManaged = case err.read.toInt of
            0: ManagedPointer CString . fromPointer (self.cSym "mat_delete") mat
            _: throw err.read.toText
        r = rows.read.toInt
        c = cols.read.toInt
        type = 0 . upto c . each (k: FieldReal)
        case readHeader of
            True:
                headerArray = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . copyRows [0]
                data   = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . cDropRow 0 
                transposed = data.cTranspose
                DataframeVal (Just headerArray) type transposed
            False:
                DataframeVal Nothing type ((Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged) . cTranspose)

    def writeToCSV filename:
        withHeader = case self.header of
            Nothing: self.data.cTranspose
            Just h :
                    
                    dataT = self.data.cTranspose
                    h.join dataT
        rows = withHeader.getSize.rows
        cols = withHeader.getSize.columns
        err = ManagedPointer CInt . malloc
        self.cCall "write_csv" None [CString.fromText filename . toCArg, withHeader.getPtr . toCArg, CInt.fromInt rows . toCArg, CInt.fromInt cols . toCArg, err.toCArg]
        case err.read.toInt of
            0: None
            _: throw err.read.toText

    def readFromXlsx file readHeader:
        err  = ManagedPointer CString . malloc
        mat  = self.cCall "read_xlsx" (Pointer CString) [CString.fromText file . toCArg, err.toCArg]
        matManaged = case err.read.isNull of
            True: ManagedPointer CString . fromPointer (self.cSym "mat_delete") mat
            False: throw (err.read.toText)
        r = rowCount matManaged
        c = columnCount matManaged
        type = 0 . upto c . each (k: FieldReal)
        case readHeader of
            True:
                headerArray = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . copyRows [0]
                data   = Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged . cDropRow 0 
                transposed = data.cTranspose
                DataframeVal (Just headerArray) type transposed
            False:
                DataframeVal Nothing type ((Array2DVal (SizeVal r c) (StrideVal c 1) 0 matManaged) . cTranspose)

    def at x y:
        record = self.data.readAt [y,x]
        record

    def selectColumns x:
        newHeader = self.header . map (k: k.copyColumns x)

        newType = x.foldLeft [] (self.selectItems self.type)
        newData = self.data.copyRows x
        DataframeVal newHeader newType newData

    def dropRows list:
        rows = 0 . upto (self.data.getSize.columns-1)
        x = rows.filter (k: list . contains k . not)
        newFrame = self.selectRows x
        newFrame

    def selectRows x:
        newData = self.data.copyColumns x
        DataframeVal self.header self.type newData

    def selectItems l1 x l2:
        n = l1.getAt x
        l22 = l2 + [n]
        l22

    def selectColumnRange a b:
        range = a . upto b
        self.selectColumns range

    def selectRowRange a b:
        range = a . upto b
        self.selectRows range

    def mapColumn n f:
        newData = self.data.mapRow n (self.type.getAt n) f
        DataframeVal self.header self.type newData

    def nubOrd l: self.nubOrd2 [] l 

    def nubOrd2 s l:
        case l of
            Prepend x xs: if (s.contains x) then (self.nubOrd2 s xs) else Prepend x (self.nubOrd2 (s.prepend x) xs)
            Empty: []
                    

    def dropNA:
        naList = self.data.findNA . filter (k: k.isJust)
        rows = naList.each (k: k.get . getAt 1) . sort . reverse
        s = self.nubOrd rows 
        dropped = self.dropRows s
        dropped


    def toJSON:
        transposedData = self.data.cTranspose
        JSON.empty . insert "header" self.headerList . insert "data" transposedData.toList
